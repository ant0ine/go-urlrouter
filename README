PACKAGE

package urlrouter

    Efficient URL routing using a Trie data structure.

    This Package implements a URL Router, but instead of using the usual
    "evaluate all the routes and return the first rexexp that matches"
    strategy, it uses a Trie data structure to perform the routing. This is
    more efficient, and scales better for a large number of routes. It
    supports the usual :param and *splat route syntax.

    Example:

	router := urlrouter.Router{
		Routes: []*urlrouter.Route{
			&urlrouter.Route{
				PathExp: "/resources/:id",
				Dest:    "one_resource",
			},
			&urlrouter.Route{
				PathExp: "/resources",
				Dest:    "all_resources",
			},
		},
	}
	err := router.Prepare()
	if err != nil {
		panic(err)
	}
	input := "http://example.org/resources/123"
	route, err := router.FindRoute(input)
	if err != nil {
		panic(err)
	}
	fmt.Print(route.Dest)

TYPES

type Route struct {
    // a string like "/resource/:id.json"
    PathExp string
    // can be anything useful to point to the code to run for this route.
    Dest interface{}
}

type Router struct {
    Routes []*Route
    // contains filtered or unexported fields
}

func (self *Router) FindRoute(url_str string) (*Route, error)
    Parse the url string (complete or just the path) and call
    FindRouteFromURL

func (self *Router) FindRouteFromURL(url_obj *url.URL) *Route
    Return the first matching Route for the given URL object.

func (self *Router) Prepare() error
    This validates the Routes and prepares the Trie data structure. It must
    be called once the Routes are defined and before trying to find Routes.


SUBDIRECTORIES

	example
	trie

