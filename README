PACKAGE

package urlrouter

    Efficient URL routing using a Trie data structure.

    This Package implements a URL Router, but instead of using the usual
    "evaluate all the routes and return the first rexexp that matches"
    strategy, it uses a Trie data structure to perform the routing. This is
    more efficient, and scales better for a large number of routes. It
    supports the :param and *splat placeholders in the route strings.

    Example:

	router := urlrouter.Router{
		Routes: []urlrouter.Route{
			urlrouter.Route{
				PathExp: "/resources/:id",
				Dest:    "one_resource",
			},
			urlrouter.Route{
				PathExp: "/resources",
				Dest:    "all_resources",
			},
		},
	}
	err := router.Start()
	if err != nil {
		panic(err)
	}
	input := "http://example.org/resources/123"
	route, err := router.FindRoute(input)
	if err != nil {
		panic(err)
	}
	fmt.Print(route.Dest)

TYPES

type Route struct {
    // A string defining the route, like "/resource/:id.json".
    // Placeholders supported are:
    // :param that matches any char to the first '/' or '.'
    // *splat that matches everything to the end of the string
    PathExp string
    // Can be anything useful to point to the code to run for this route.
    Dest interface{}
}

type Router struct {
    Routes []Route
    // contains filtered or unexported fields
}

func (self *Router) FindRoute(url_str string) (*Route, error)
    Parse the url string (complete or just the path) and call
    FindRouteFromURL

func (self *Router) FindRouteFromURL(url_obj *url.URL) *Route
    Return the first matching Route for the given URL object.

func (self *Router) Start() error
    This validates the Routes and prepares the Trie data structure. It must
    be called once the Routes are defined and before trying to find Routes.


SUBDIRECTORIES

	example
	trie

